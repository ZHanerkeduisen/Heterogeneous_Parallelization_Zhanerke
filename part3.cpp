// Практика 1 часть 3 (Динамическа память и указатели)
// 1. Создать динамический массив и запонять его случайными числами
// 2. Вычислить среднее значение: последовательный способом и с использованием OpenMP с редукцией
// 3. Замерить время выполнения алгоритма
// 4. Сравнить время обоих реализации
// 5. Освободить память, выделенную под массив


#include <iostream>   // Для работы с вводом/выводом (cout, cin, endl)
#include <random>     // Для генерации случайных чисел (random_device, mt19937, uniform_int_distribution)
#include <omp.h>      // Для параллельных вычислений OpenMP
#include <chrono>     // Для измерения времени выполнения

using namespace std;  // Стандартное пространство имён, чтобы не писать std:: перед cout, endl и т.д.

// Функция для вычисления среднего значения массива (последовательно)
double calculateAverage(int* arr, int size) {     // arr - указатель на массив целых чисел, size - количество элементов в массиве
    double sum = 0;                               // Переменная для хранения суммы элементов
    for (int i = 0; i < size; i++) {              // Цикл проходит по всем элементам массива
        sum += arr[i];                            // Добавляем текущий элемент к сумме sum
    }
    return sum / size;                            // Делим сумму на количество элементов и возвращаем среднее значение
}

int main() {                        // Основная функция
    int N;                          // Размер массива
    cout << "Введите размер массива: ";
    cin >> N;

    // Динамическое выделение памяти
    int* arr = new int[N];           // int* - указатель на int
                                     // new int[SIZE] - выделяем память   

    // Настройка генератора случайных чисел
    random_device rd;                // random_device используется как источник случайности
    mt19937 gen(rd());               // mt19937 — генератор случайных чисел Mersenne Twister
                                     // Инициализируем его значением из rd(), чтобы последовательность была случайной
   
    uniform_int_distribution<int> dist(1, 100);    // uniform_int_distribution задаёт равномерное распределение чисел от 1 до 1000000
                                                   // dist(gen) будет возвращать случайное число из этого диапазона

    // Заполнение массива случайными числами
    cout << "Массив: ";
    for (int i = 0; i < N; i++) {    // Цикл проходит по всем элементам массива
        arr[i] = dist(gen);          // Генерируем случайное число (в нашем случае 0т 1 до 100) и записываем его в массив
        cout << arr[i] << " ";       // Выводим элемент массива
    }
    cout << endl;                    // Переход на новую строку

    // ПОСЛЕДОВАТЕЛЬНОЕ ВЫЧИСЛЕНИЕ
    auto start_seq = chrono::high_resolution_clock::now(); // Начало замера времени

    double avg_seq = calculateAverage(arr, N);             // Вызываем функцию вычисления среднего значения

    auto end_seq = chrono::high_resolution_clock::now();   // Конц замера времени
    chrono::duration<double, milli> duration_seq = end_seq - start_seq;    // Вычисляем длительность последовательного алгоритма

    cout << "Последовательное среднее значение =  " << avg_seq << endl;
    cout << "Продолжительность последовательного вычисление =  " << duration_seq.count() << " ms" << endl;

    // ПАРАЛЛЕЛЬНОЕ ВЫЧИСЛЕНИЕ 
    auto start_par = chrono::high_resolution_clock::now();  // Начало замера времени

    double sum_par = 0;             // Общая сумма (будет использоваться в reduction)

    #pragma omp parallel for reduction(+:sum_par)      // Цикл выполняется в нескольких потоках
    // OpenMP:
             // - цикл выполняется параллельно
             // - каждый поток имеет свою локальную sum_par
             // - в конце OpenMP складывает все суммы
    for (int i = 0; i < N; i++) {   // Цикл распределяется между потоками
        sum_par += arr[i];          // Каждый поток считает свою часть суммы
    }

    double avg_par = sum_par / N;   // Вычисляем среднее значение

    auto end_par = chrono::high_resolution_clock::now();                  // Конец замера времени
    chrono::duration<double, milli> duration_par = end_par - start_par;   // Вычисляем длительность параллельного алгоритма

    cout << "Параллельное среднее значение: " << avg_par << endl;
    cout << "Продолжительность параллельного вычисления: " << duration_par.count() << " ms" << endl;

    // Освобождение памяти
    delete[] arr;             // Освобождаем память, выделенную под массив, чтобы избежать утечки памяти
                              // Используем [] после delete, так как массив был выделен через new[]
    return 0;                 // Возвращаем 0, что означает успешное завершение программы
}                             // Конец основной функции (main)
