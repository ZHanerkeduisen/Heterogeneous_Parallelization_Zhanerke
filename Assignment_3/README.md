Zhanerke Duisen, ADA - 2403M

Assignment 3

Блок-схемы в файле "БЛОК-СХЕМЫ"

Ответы на контрольные вопросы в файле "Контрольные вопросы assignment3.docx"

Описание: 
Проект демонстрирует основы программирования на CUDA, с фокусом на:

 - иерархию памяти GPU (глобальная, shared, регистры);

 - настройку потоков и блоков;

 - оптимизацию производительности.

Цели проекта:

 - Понять иерархию памяти CUDA и её влияние на скорость работы.

 - Научиться точно измерять время выполнения GPU kernel с помощью CUDA Events.

 - Исследовать, как параллельные вычисления и конфигурация блоков/сетки влияют на производительность.

________________________________________________________________________________________________________________________________________________________________

Оборудованиеи: NVIDIA GPU CUDA
Программное обеспечение: CUDA, Компилятор C++ (nvcc), Google Colab с GPU.

________________________________________________________________________________________________________________________________________________________________

Заданиеи 1 – Поэлементное умножение (Assignment3_task1.ipynb)

Цель: Сравнить производительность глобальной и shared памяти при обработке массива.

Описание kernel:

 - Global memory version: каждый поток умножает элемент массива напрямую в глобальной памяти.

 - Shared memory version: блок элементов сначала загружается в shared memory, обрабатывается, затем записывается обратно в глобальную память.


<img width="708" height="425" alt="image" src="https://github.com/user-attachments/assets/f6813692-0667-42db-b4b9-ab9633eade82" />

Результат: 
 - Глобальная память: медленнее (~0.0077 с для 1 000 000 элементов)

 - Shared memory: значительно быстрее (~0.000003 с для 1 000 000 элементов)

__________________________________________________________________________________________________________________________________________________________________

Задание 2 – Поэлементное сложение (Assignment3_task2.ipynb)

Цель: Изучить, как размер блока потоков влияет на производительность.

Описание kernel:

Каждый поток выполняет C[i] = A[i] + B[i].

Измеряем время для разных размеров блока: 128, 256, 512 потоков на блок.

<img width="633" height="434" alt="image" src="https://github.com/user-attachments/assets/3b433dcd-0bb5-4f52-8256-b451c7c055af" />


Результат: Большие блоки (256–512 потоков) лучше загружают GPU и ускоряют выполнение.

____________________________________________________________________________________________________________________________________________________________

Задание 3 – Коалесцированный vs некоалесцированный доступ (Assignment3_task3.ipynb)

Цель: Показать, как шаблон доступа к памяти влияет на производительность.

Описание kernel:
1. Ядро с коалесцированным доступом (coalesced_kernel)

 - Потоки обращаются к последовательным ячейкам памяти

 - Пример: поток 0 → элемент 0, поток 1 → элемент 1, и т.д.

 - Оптимальный вариант - GPU может объединять обращения в памяти

2. Ядро с некоалесцированным доступом (noncoalesced_kernel)

 - Потоки обращаются к несмежным ячейкам памяти с большим шагом (997)

 - Пример: поток 0 → элемент 0, поток 1 → элемент 997, поток 2 → элемент 1994

 - Неоптимальный вариант - требует больше транзакций памяти

<img width="785" height="417" alt="image" src="https://github.com/user-attachments/assets/cc4d3b6e-3a85-41dc-8aa4-f4f7cf0256d9" />


Результат: Почему разница может быть небольшой на T4:

Большой кэш L2 (40MB) - компенсирует неоптимальный доступ

Аппаратная оптимизация - современные GPU лучше справляются с некоалесцированным доступом

Предварительное чтение - GPU предугадывает нужные данные

______________________________________________________________________________________________________________________________________________________________

Задание 4 – Оптимизация сетки и блоков (Assignment3_task4.ipynb)

Цель: Найти оптимальные размеры блока и сетки для максимальной производительности CUDA-ядра.

Реализация:

Kernel: поэлементное умножение массива (как в Задании 1).

Сравниваем неоптимальную конфигурацию (32 потока на блок) и оптимальную (256 потоков на блок).

<img width="751" height="344" alt="image" src="https://github.com/user-attachments/assets/a4a08cbf-2af4-4acd-8b90-7b6b93341789" />


Результат: Оптимальная конфигурация полностью загружает GPU и значительно ускоряет выполнение.

______________________________________________________________________________________________________________________________________________________________________-

# Компиляция и запуск в Google Colab:

 Сохраняем программу в файл
%%writefile assignment3.cu
[код программы]

 Компилируем
!nvcc assignment3.cu -o assignment3

 Запускаем
!./assignment3
