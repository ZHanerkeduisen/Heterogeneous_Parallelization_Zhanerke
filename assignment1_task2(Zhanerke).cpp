// ЗДЕСЬ РЕШЕНИЕ ЗАДАНИЕ 2 И ЗАДАНИЕ 3
// Задание 2
// 1. Создать массив из 1 000 000 целых чисел
// 2. Последовательный поиск минимального и максимального элементов
// 3. Замерить время выполнения алгоритма

#include <iostream>     // Для работы с вводом/выводом (cout, cin, endl)
#include <random>       // Для генерации случайных чисел (random_device, mt19937, uniform_int_distribution)
#include <chrono>       // Для измерения времени выполнения
#include <omp.h>        // Для OpenMP (параллельные вычисления) для 3 задание
using namespace std;    // Стандартное пространство имён, чтобы не писать std:: перед cout, endl и т.д.

int main() {            // Основная функция
    // Размер массива
    const int SIZE = 1000000;       // Объявляем константу SIZE — размер массива. Используем const, чтобы размер нельзя было случайно изменить в программ
    // Динамическое выделение памяти
    int* arr = new int[SIZE];        // int* - указатель на int
                                     // new int[SIZE] - выделяем память   
                                     // Создаём динамический массив типа int с размером SIZE (1000000)

    // Настройка генератора случайных чисел
    random_device rd;                  // random_device используется как источник случайности
    mt19937 gen(rd());                 // mt19937 — генератор случайных чисел Mersenne Twister
                                       // Инициализируем его значением из rd(), чтобы последовательность была случайной
    
    uniform_int_distribution<int> dist(1, 1000000);   // uniform_int_distribution задаёт равномерное распределение чисел от 1 до 1000000 (можно изменить)
                                                      // dist(gen) будет возвращать случайное число из этого диапазона

    
    // Заполнение массива случайными числами
    for (int i = 0; i < SIZE; ++i) {   // ++i используется для увеличения i перед следующей итерацией (префиксный инкремент)
        arr[i] = dist(gen);            // Для каждого индекса i от 0 до SIZE-1 генерируем случайное число dist(gen) и записываем его в массив 
    }

    
    // Вывод первых 100 элементов массива
    cout << "Первые 100 элементов массива:\n";   // Выводим заголовок перед числами

    for (int i = 0; i < 100 && i < SIZE; ++i) {  // Проходим максимум по 100 элементам или меньше, если SIZE < 100
        cout << arr[i] << " ";                   // Выводим текущий элемент массива, разделяя пробелом
    }
    cout << "\n...\n";                           // // Выводим многоточие, чтобы показать, что остальные элементы не отображаются
                                                 // Это предотвращает захламление консоли большим массивом

    // ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК MIN/MAX                                           
    // Измерение времени последовательного поиска min/max
    auto start_time_s = chrono::high_resolution_clock::now();  // Начало замера времени

    int min_val_s = arr[0];             // Инициализируем минимальное значение первым элементом массива
    int max_val_s = arr[0];             // Инициализируем максимальное значение первым элементом массива

    for (int i = 1; i < SIZE; ++i) {    // Проходим по всем элементам массива, начиная с второго элемента (индекс 1)
        if (arr[i] < min_val_s) {       // Если текущий элемент меньше min_val_s
            min_val_s = arr[i];         // Обновляем минимальное значение
        }
        if (arr[i] > max_val_s) {      // Если текущий элемент больше max_val_s
            max_val_s = arr[i];        // Обновляем максимальное значение
        }
    }

    auto end_time_s = chrono::high_resolution_clock::now();  // Конец замера времени

    chrono::duration<double, milli> duration_s = end_time_s - start_time_s;  // Вычисляем разницу времени в миллисекундах

    
    // Вывод 
    cout << "\nПоследовательный поиск:\n";
    cout << "Минимальное значение = " << min_val_s << endl;        // Выводим минимальное значение
    cout << "Максимальное значение = " << max_val_s << endl;       // Выводим максимальное значение
    cout << "Продолжительность последовательного поиска = " << duration_s.count() << " ms\n";  // Выводим затраченное время на выполнение поиска

// ЗАДАНИЕ 3
// 1. Создать массив из 1 000 000 целых чисел
// 2. Параллельный поиск минимального и максимального элементов
// 3. Замерить время выполнения алгоритма
// 4. Сравнить время обоих реализации
    
    // ПAРАЛЛЕЛЬНЫЙ ПОИСК MIN/MAX
    auto start_time_p = chrono::high_resolution_clock::now();  // Начало замера времени

    int global_min = arr[0];           // Глобальный минимальный элемент массива (для всех потоков)
    int global_max = arr[0];           // Глобальный максимальный элемент массива (для всех потоков)

    #pragma omp parallel               // Начало параллельного блока
    {
        int local_min = arr[0];        // Локальный min для каждого потока
        int local_max = arr[0];        // Локальный max для каждого потока

        #pragma omp for                // Распределяем цикл между потоками
        for (int i = 1; i < SIZE; ++i) {
            if (arr[i] < local_min) local_min = arr[i];  // Находим локальный минимум
            if (arr[i] > local_max) local_max = arr[i];  // Находим локальный максимум
        }

        
        #pragma omp critical           // Критическая секция для обновления глобальных значений
        {                              // После окончания работы каждого потока локальные значения сравниваются с глобальными значениями
            if (local_min < global_min) global_min = local_min;  // Обновляем глобальный минимум
            if (local_max > global_max) global_max = local_max;  // Обновляем глобальный максимум
        }
    }

    auto end_time_p = chrono::high_resolution_clock::now();  // Конец замера времени

    chrono::duration<double, milli> duration_p = end_time_p - start_time_p;  // Вычисляем разницу времени в миллисекундах

    
    // Вывод результатов
    cout << "\nПараллельный поиск с OpenMP:\n";
    cout << "Минимальное значение = " << global_min << endl;       // Вывод глобального минимума
    cout << "Максимальное значение = " << global_max << endl;       // Вывод глобального максимума
    cout << "Продолжительность паралельного поиска = " << duration_p.count() << " ms\n";  

    // Освобождение динамической памяти
    delete[] arr;                    // Освобождаем память, выделенную под массив, чтобы избежать утечки памяти
                                     // Используем [] после delete, так как массив был выделен через new[]
    return 0;                        // Возвращаем 0, что означает успешное завершение программы
}                                    // Конец основной функции (main)


