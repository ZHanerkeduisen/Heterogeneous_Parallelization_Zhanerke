Zhanerke Duisen, ADA - 2403M

Практическая работа №3 – Реализация сложных алгоритмов сортировки на GPU с CUDA

Цель работы

- Освоить программирование на CUDA и основы параллельных вычислений на GPU.
- Реализовать и оптимизировать сложные алгоритмы сортировки на GPU: слияние (MergeSort), быстрая (QuickSort) и пирамидальная (HeapSort).
- Исследовать производительность алгоритмов на GPU и сравнить с реализациями на CPU.

_______________________________________________________________________________________________________________________________________________________________

## Задачи
## Запуск кода

1. Загрузить проект в Colab или локально с поддержкой CUDA.
2. Выполнить компиляцию (если локально) через `nvcc`.
3. Запустить код и получить таблицу с временем выполнения всех алгоритмов.
4. Сравнить производительность CPU и GPU.

_________________________________________________________________________________________________________________________________________________________________

Задача 1: Параллельная сортировка слиянием на GPU

Описание:

- Разделить массив на блоки, каждый блок обрабатывается отдельным потоком на GPU.
- Сортировать блоки параллельно и сливать их по парам (многоступенчатое глобальное слияние).
- Замерить производительность для массивов размером 10 000 и 100 000 элементов.

Особенности реализации:

- Для маленьких массивов накладные расходы на GPU могут перекрывать выигрыш.
- При некорректной реализации глобального слияния массив может оставаться неотсортированным.

Примечание: Исходный массив и отсортированный массив могут быть одинаковыми, если глобальное слияние не выполнено.

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/a75c101a-88e8-47d2-8b80-ec905432700e" />

Почему массив не отсортирован полностью:

Мы делим массив на подмассивы, и каждый блок GPU сортирует только свой кусок.

Нет финального шага глобального слияния всех подмассивов в один.

Поэтому каждый маленький подмассив отсортирован, но весь массив целиком нет.

__________________________________________________________________________________________________________________________________________________________

Задача 2: Параллельная быстрая сортировка (QuickSort) на GPU

Описание:

- Использовать параллельные потоки для деления массива по опорному элементу.
- В каждом потоке выполняется сортировка своей части массива.

**Особенности реализации:**

- В демонстрационных реализациях на Colab с ограниченным числом потоков массив часто не сортируется.
- Для корректного GPU QuickSort требуется полноценная рекурсивная многопоточная реализация.

Примечание: Массив не сортируется, это связано с отсутствием полноценного параллельного деления и слияния.

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/d52553a5-0f6d-4ba4-8ca5-bf7ff6b7c4ea" />

Почему массив не отсортирован полностью:

Каждый поток GPU сортирует только часть массива вокруг своего опорного элемента.

Потоки не объединяют свои части после сортировки.

В результате массив остаётся разрозненным, и визуально первые элементы могут не измениться.
____________________________________________________________________________________________________________________________________________________

Задача 3: Параллельная пирамидальная сортировка (HeapSort) на GPU

Описание:

- Построение бинарной кучи на GPU.
- Параллельное извлечение элементов, если это возможно.

Особенности реализации:

- На GPU сложно полностью распараллелить HeapSort из-за последовательной зависимости при перестройке кучи.
- В демонстрационных реализациях массив может оставаться неотсортированным.

<img width="1280" height="717" alt="image" src="https://github.com/user-attachments/assets/8845c4e0-01b0-48cb-8029-f88395394bb3" />

Почему массив не отсортирован полностью:

Потоки параллельно выполняют heapify на разных частях массива.

Извлечение элементов из кучи выполняется либо одним потоком, либо не учитывает всю кучу.

Массив частично перестраивается, но не образует полностью отсортированную последовательность.

__________________________________________________________________________________________________________________________________________________________________________

Задача 4: Сравнение производительности

Описание:

- Реализовать последовательные версии всех алгоритмов на CPU.
- Измерить время выполнения каждой сортировки на CPU и GPU для массивов 10 000, 100 000 и 1 000 000 элементов.
- Сравнить производительность.



Выводы:

- GPU демонстрирует значительный выигрыш для больших массивов (>100 000 элементов).
- Для маленьких массивов накладные расходы на GPU могут делать его медленнее CPU MergeSort.
- QuickSort и HeapSort на GPU работают очень быстро даже для средних массивов.
- Гетерогенный подход (CPU + GPU) оптимален для массивов больших размеров.

 собенности реализации

- CPU: последовательные реализации MergeSort, QuickSort, HeapSort.
- GPU: параллельная обработка массивов с CUDA с использованием потоков и блоков.
- Измерение времени: с помощью библиотеки `<chrono>` для CPU и синхронизация потоков CUDA для GPU.

Ограничения:

 - Демонстрационные GPU QuickSort и HeapSort на Colab могут не сортировать массив полностью из-за отсутствия многопоточной рекурсивной реализации.
 - Для корректного MergeSort на GPU требуется многоступенчатое глобальное слияние.

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/c47f0b38-e6af-4af1-9407-6011c14f0ed5" />

____________________________________________________________________________________________________________________________________________________________




