// Задание 4
// 1. Создать динамический массив из 50 000 целых чисел
// 2. Вычислить среднее значение: последовательный способом и с использованием OpenMP с редукцией
// 3. Замерить время выполнения алгоритма
// 4. Сравнить время обоих реализации
#include <iostream>     // Для работы с вводом/выводом (cout, cin, endl)
#include <random>       // Для генерации случайных чисел (random_device, mt19937, uniform_int_distribution)  
#include <chrono>       // Для измерения времени выполнения
#include <omp.h>        // Для параллельных вычислений OpenMP

using namespace std;    // Стандартное пространство имён, чтобы не писать std:: перед cout, endl и т.д.

int main() {            // Основная функция
    // Размер массива
    const int SIZE = 5000000;             // Объявляем константу SIZE — размер массива. Используем const, чтобы размер нельзя было случайно изменить в программ
    // Динамическое выделение памяти
    int* arr = new int[SIZE];             // int* - указатель на int
                                          // new int[SIZE] - выделяем память   
                                          // Создаём динамический массив типа int с размером SIZE (5000000)

    // Настройка генератора случайных чисел 
    random_device rd;                      // random_device используется как источник случайности
    mt19937 gen(rd());                     // mt19937 — генератор случайных чисел Mersenne Twister
                                           // Инициализируем его значением из rd(), чтобы последовательность была случайной

    uniform_int_distribution<int> dist(1, 5000000);    // uniform_int_distribution задаёт равномерное распределение чисел от 1 до 5000000
                                                    // dist(gen) будет возвращать случайное число из этого диапазона

    // Заполнение массива случайными числами
    for (int i = 0; i < SIZE; ++i) {                // ++i используется для увеличения i перед следующей итерацией (префиксный инкремент)
        arr[i] = dist(gen);                         // Для каждого индекса i от 0 до SIZE-1 генерируем случайное число dist(gen) и записываем его в массив 
    }

    // Вывод первых 100 элементов массива
    cout << "Первые 100 элементов массива:\n";      // Выводим заголовок перед числами
    
    for (int i = 0; i < 100 && i < SIZE; ++i) {     // Проходим максимум по 100 элементам или меньше, если SIZE < 100
        cout << arr[i] << " ";                      // Выводим текущий элемент массива, разделяя пробелом
    }
    cout << "\n...\n";                              // Выводим многоточие, чтобы показать, что остальные элементы не отображаются
                                                    // Это предотвращает захламление консоли большим массивом


    // ПОСЛЕДОВАТЕЛЬНОЕ ВЫЧИСЛЕНИЕ СРЕДНЕГО ЗНАЧЕНИЕ
    // Измерение времени последовательного вычисление
    auto start_seq = chrono::high_resolution_clock::now();   // Начало замера времени

    long long sum_seq = 0;                          // Создаём переменную sum типа long long для хранения суммы элементов
                                                    // Используем long long, чтобы избежать переполнения при суммировании 500 000 чисел

    for (int i = 0; i < SIZE; ++i) {
        sum_seq += arr[i];                          // Для каждого элемента массива добавляем его значение к sum
  
    }

    double avg_seq = static_cast<double>(sum_seq) / SIZE;      // Преобразуем sum в тип double и делим на SIZE, чтобы получить среднее значение с плавающей точкой
                                                               // static_cast<double> гарантирует точное деление, иначе результат был бы целым числом


    auto end_seq = chrono::high_resolution_clock::now();             // Конец замера конца

    chrono::duration<double, milli> time_seq = end_seq - start_seq;  // Вычисляем длительность последовательного алгоритма

    
    // ПАРАЛЛЕЛЬНОЕ ВЫЧИСЛЕНИЕ СРЕДНЕГО с OpenMP и reduction
    auto start_par = chrono::high_resolution_clock::now();           // Начало замера времени

    long long sum_par = 0;                                           // Глобальная переменная суммы (будет использоваться в reduction)

    #pragma omp parallel for reduction(+:sum_par)                    // Цикл выполняется в нескольких потоках
    // OpenMP:
    //        - массив делится между потоками
    //        - каждый поток считает свою локальную сумму
    //        - OpenMP автоматически суммирует результаты
    for (int i = 0; i < SIZE; ++i) {
        sum_par += arr[i];                                            // Для каждого элемента массива добавляем его значение к sum_par       
    }

    double avg_par = static_cast<double>(sum_par) / SIZE;             // Делим сумму на размер массива и получаем среднее значение

    auto end_par = chrono::high_resolution_clock::now();              // Конец замера времени

    chrono::duration<double, milli> time_par = end_par - start_par;   // Вычисляем длительность параллельного алгоритма

    
    // Вывод
    cout << "\nПоследовательное среднее значенние = " << avg_seq << endl;
    cout << "Параллельное среднее значение = " << avg_par << endl;

    cout << "\nПродолжительность последовательного вычисление = " << time_seq.count() << " ms" << endl;
    cout << "Продолжительность параллельного вычисление = " << time_par.count() << " ms" << endl;

    

    // Освобождение памяти
    delete[] arr;                     // Освобождаем память, выделенную под массив, чтобы избежать утечки памяти
                                      // Используем [] после delete, так как массив был выделен через new[]
    return 0;                         // Возвращаем 0, что означает успешное завершение программы
}                                     // Конец основной функции (main)

